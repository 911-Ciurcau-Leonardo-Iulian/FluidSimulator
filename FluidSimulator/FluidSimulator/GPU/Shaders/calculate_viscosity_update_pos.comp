#version 430 core
layout (local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

layout(std140, binding = 0) uniform Settings {
    uint num_particles;
    float gravity;
    float delta_time;
    float collision_damping;
    float smoothing_radius;
    float target_density;
    float pressure_multiplier;
    float near_pressure_multiplier;
    float viscosity_strength;
    float poly6_scaling_factor;
    float spiky_pow3_scaling_factor;
    float spiky_pow2_scaling_factor;
    float spiky_pow3_derivative_scaling_factor;
    float spiky_pow2_derivative_scaling_factor;
    vec2 interaction_input_point;
    float interaction_input_strength;
    float interaction_input_radius;
    //vec2 obstacle_size;
    //vec2 obstacle_centre;
};

// Constants used for hashing
const uint hashK1 = 15823;
const uint hashK2 = 9737333;

// Convert floating point position into an integer cell coordinate
ivec2 GetCell2D(vec2 position, float radius)
{
	return ivec2(floor(position / radius));
}

// Hash cell coordinate to a single unsigned integer
uint HashCell2D(ivec2 cell)
{
	uvec2 unsigned_cell = uvec2(cell);
	uint a = unsigned_cell.x * hashK1;
	uint b = unsigned_cell.y * hashK2;
	return (a + b);
}

uint KeyFromHash(uint hash, uint tableSize)
{
	return hash % tableSize;
}

const ivec2 offsets2D[9] =
{
	ivec2(-1, 1),
	ivec2(0, 1),
	ivec2(1, 1),
	ivec2(-1, 0),
	ivec2(0, 0),
	ivec2(1, 0),
	ivec2(-1, -1),
	ivec2(0, -1),
	ivec2(1, -1),
};

layout(std430, binding = 0) readonly buffer _Densities
{
    vec2 Densities[];
};

layout(std430, binding = 1) readonly buffer _PredictedPositions
{
    vec2 PredictedPositions[];
};

layout(std430, binding = 2) readonly buffer _SpatialOffsets
{
    uint SpatialOffsets[];
};

struct SpatialIndex {
    uint index;
    uint hash;
    uint key;
};

layout(std430, binding = 3) readonly buffer _SpatialIndices
{
    SpatialIndex SpatialIndices[];
};

layout(std430, binding = 4) buffer _Velocities {
    vec2 Velocities[];
};

layout(std430, binding = 5) buffer _Positions {
    vec2 Positions[];
};

float SmoothingKernelPoly6(float dst, float radius)
{
	if (dst < radius)
	{
		float v = radius * radius - dst * dst;
		return v * v * v * poly6_scaling_factor;
	}
	return 0;
}

float SpikyKernelPow3(float dst, float radius)
{
	if (dst < radius)
	{
		float v = radius - dst;
		return v * v * v * spiky_pow3_scaling_factor;
	}
	return 0;
}

float SpikyKernelPow2(float dst, float radius)
{
	if (dst < radius)
	{
		float v = radius - dst;
		return v * v * spiky_pow2_scaling_factor;
	}
	return 0;
}

float DerivativeSpikyPow3(float dst, float radius)
{
	if (dst <= radius)
	{
		float v = radius - dst;
		return -v * v * spiky_pow3_derivative_scaling_factor;
	}
	return 0;
}

float DerivativeSpikyPow2(float dst, float radius)
{
	if (dst <= radius)
	{
		float v = radius - dst;
		return -v * spiky_pow2_derivative_scaling_factor;
	}
	return 0;
}

float DensityKernel(float dst, float radius)
{
	return SpikyKernelPow2(dst, radius);
}

float NearDensityKernel(float dst, float radius)
{
	return SpikyKernelPow3(dst, radius);
}

float DensityDerivative(float dst, float radius)
{
	return DerivativeSpikyPow2(dst, radius);
}

float NearDensityDerivative(float dst, float radius)
{
	return DerivativeSpikyPow3(dst, radius);
}

float PressureFromDensity(float density)
{
	return (density - target_density) * pressure_multiplier;
}

float NearPressureFromDensity(float near_density)
{
	return near_pressure_multiplier * near_density;
}

float ViscosityKernel(float dst, float radius)
{
	return SmoothingKernelPoly6(dst, smoothing_radius);
}

void CalculateViscosity (uint id)
{		
	vec2 pos = PredictedPositions[id];
    ivec2 origin_cell = GetCell2D(pos, smoothing_radius);
    float sqr_radius = smoothing_radius * smoothing_radius;

    vec2 viscosity_force = vec2(0);
    vec2 current_velocity = Velocities[id.x];

    for (int i = 0; i < 9; i++)
    {
        uint hash = HashCell2D(origin_cell + offsets2D[i]);
        uint key = KeyFromHash(hash, num_particles);
        uint curr_index = SpatialOffsets[key];

        while (curr_index < num_particles)
        {
            SpatialIndex index_data = SpatialIndices[curr_index];
            curr_index++;
            // Exit if no longer looking at the correct bin
            if (index_data.key != key) break;
            // Skip if hash does not match
            if (index_data.hash != hash) continue;

            uint neighbour_index = index_data.index;
            // Skip if looking at self
            if (neighbour_index == id) continue;

            vec2 neighbour_pos = PredictedPositions[neighbour_index];
            vec2 offset_to_neighbour = neighbour_pos - pos;
            float sqr_dst_to_neighbour = dot(offset_to_neighbour, offset_to_neighbour);

            // Skip if not within radius
            if (sqr_dst_to_neighbour > sqr_radius) continue;

            float dst = sqrt(sqr_dst_to_neighbour);
            vec2 neighbour_velocity = Velocities[neighbour_index];
            viscosity_force += (neighbour_velocity - current_velocity) * ViscosityKernel(dst, smoothing_radius);
        }
    }

    Velocities[id.x] -= viscosity_force * viscosity_strength * delta_time;
}

void HandleCollisions(uint id) {
    vec2 pos = Positions[id];
	vec2 vel = Velocities[id];

	// Keep particle inside bounds
	if (pos.x < -1.0f * 2000.0f)
	{
		pos.x = -1.0f * 2000;
		vel.x *= -1 * collision_damping;
	}
    if (pos.x > 1.0f * 2000)
    {
        pos.x = 1.0f * 2000;
        vel.x *= -1 * collision_damping;
    }
	if (pos.y < -1.0f * 2000)
	{
		pos.y = -1.0f * 2000;
		vel.y *= -1 * collision_damping;
	}
    if (pos.y > 1.0f * 2000)
    {
        pos.y = 1.0f * 2000;
        vel.y *= -1 * collision_damping;
    }

	// Collide particle against the test obstacle
//	const vec2 obstacleHalfSize = obstacleSize * 0.5;
//	vec2 obstacleEdgeDst = obstacleHalfSize - abs(pos - obstacleCentre);
//
//	if (obstacleEdgeDst.x >= 0 && obstacleEdgeDst.y >= 0)
//	{
//		if (obstacleEdgeDst.x < obstacleEdgeDst.y) {
//			pos.x = obstacleHalfSize.x * sign(pos.x - obstacleCentre.x) + obstacleCentre.x;
//			vel.x *= -1 * collisionDamping;
//		}
//		else {
//			pos.y = obstacleHalfSize.y * sign(pos.y - obstacleCentre.y) + obstacleCentre.y;
//			vel.y *= -1 * collisionDamping;
//		}
//	}

	// Update position and velocity
	Positions[id] = pos;
	Velocities[id] = vel;
}

void UpdatePositions(uint id)
{
	Positions[id.x] += Velocities[id.x] * delta_time;
	HandleCollisions(id);
}

void main()
{
    uvec3 id = gl_GlobalInvocationID;
    if (id.x > num_particles) return;

    CalculateViscosity(id.x);

    // At last we can update the positions based on the velocity and we must handle the collisions
    // With the screen edge
    UpdatePositions(id.x);
}
